package za.co.wethinkcode;

import java.util.*;

public class KataSolutions {

    static int descendingOrder(int number){
        boolean isPos = number > 0;
        number = Math.abs(number);

        List<Integer> listNum = new ArrayList<>();
        int reversed = 0;

        // Convert each digit to an integer and add to list
        for(Character k : String.valueOf(number).toCharArray()){
            String strK = Character.toString(k);
            int intK = Integer.parseInt(strK);
            listNum.add(intK);
        }
        // Sort digits in descending order
        listNum.sort(Comparator.reverseOrder());

        // Reconstruct the number from the sorted digits
        for(int k = 0; k < listNum.size(); k++){
            reversed += listNum.get(k) * Math.pow(10, listNum.size() - (k + 1));
        }
        return isPos ? reversed : -reversed;
    }    
    
    static int descendingOrder2(int number){
        boolean isPos = number > 0;
        number = Math.abs(number);

        List<Integer> listNum = new ArrayList<>();
        StringBuilder strNum = new StringBuilder();

        // Extract digits to list
        for(Character k : String.valueOf(number).toCharArray()){
            String strK = Character.toString(k);
            int intK = Integer.parseInt(strK);
            listNum.add(intK);
        }
        // Sort digits in descending order
        listNum.sort(Comparator.reverseOrder());

        // Rebuild number as string
        for(Integer n : listNum){
            strNum.append(n);
        }
        
        return isPos ? Integer.parseInt(strNum.toString()): -Integer.parseInt(strNum.toString());
    }
        


    public static int vowelCount1(String str){
        List<Character> vowels = List.of('a', 'e', 'i', 'o', 'u');
        int vowelCount = 0;
        // Iterate through each character and check if it's a vowel
        for(Character k : str.toLowerCase().toCharArray()){
            if(vowels.contains(k)) vowelCount ++;
        }
        return vowelCount;
    }
    
    public static int vowelCount2(String str){
        // Convert to char stream, filter for vowels, and count
        return (int) str.toLowerCase().chars().filter(k -> "aeiou".indexOf(k) >= 0).count();
    }

    public static long vowelCount3(String str){
        // Remove all non-vowels and count the remaining characters
        return str.toLowerCase().replaceAll("[^aeiou]", "").length();
    }



    public static int findNextSquare(int number){
        int sqroot = (int) Math.sqrt(number);
        boolean isSquare = sqroot * sqroot == number;
        return isSquare ? (sqroot + 1)*(sqroot + 1) : -1;
    }


    static String uniqueLetters(String str1, String str2) {
        // TreeSet provides automatic sorting and uniqueness
        Set<Character> uniqueChars = new TreeSet<>();  
        
        String combined = (str1 + str2).toLowerCase();
        // Add only alphabetic characters to set
        for (char c : combined.toCharArray()) {
            if(Character.isAlphabetic(c)){
                uniqueChars.add(c);
            }
        }
        List<Character> sortedChars = new ArrayList<>(uniqueChars);
        Collections.sort(new ArrayList<>(sortedChars));
        
        // Build result string from sorted unique characters
        StringBuilder result = new StringBuilder();
        for (Character c : sortedChars) {
            result.append(c);
        }
        
        return result.toString();
    }

    static String uniqueLetters2 (String str1, String str2) {
        String combined = (str1 + str2).toLowerCase();
        StringBuilder result = new StringBuilder();
        combined.chars().distinct().sorted().filter(n -> Character.isAlphabetic(n)).forEach(k -> result.append((char) k));
        return result.toString();
    }

    static String uniqueLetters3 (String s1, String s2) {
        String s = s1 + s2;
        // Process chars as a stream: make distinct, sort, and collect into string
        return s.chars().distinct().sorted().collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();
    }


    static String createPhoneNumber(int[] numbers) {
        // Manually construct phone number with specific formatting
        StringBuilder strNumber = new StringBuilder("(");
        for(int n = 0; n < 3; n++) strNumber.append(numbers[n]);
        strNumber.append(") ");
        for(int n = 3; n < 6; n++) strNumber.append(numbers[n]);
        strNumber.append("-");
        for(int n = 6; n < 10; n++) strNumber.append(numbers[n]);
        return strNumber.toString();
    }

    public static String createPhoneNumber2(int[] numbers) {
        // Convert int[] to Object[] for variadic arguments
        Object[] arrayStream = java.util.stream.IntStream.of(numbers).boxed().toArray();
        return String.format("(%d%d%d) %d%d%d-%d%d%d%d", arrayStream);
    }

    public static String createPhoneNumber3(int[] numbers) {
        // Directly reference array indices for formatting
        return String.format("(%d%d%d) %d%d%d-%d%d%d%d", 
                            numbers[0], numbers[1], numbers[2], numbers[3], numbers[4], 
                            numbers[5], numbers[6], numbers[7], numbers[8], numbers[9]);
    }
    

    static boolean pangram(String sentence){
        // Use HashSet to track unique alphabetic characters
        Set<Character> unique = new HashSet<>();
        for(char c: sentence.toLowerCase().toCharArray()){
            if(Character.isAlphabetic(c)){
                unique.add(c);
            }
        }
        // Check if all 26 letters are present
        return unique.size() == 26;
    }

    static boolean pangram2(String sentence){
        // Count unique alphabetic characters using streams
        int uniqueAlphaCount = (int) sentence.toLowerCase().chars()
                                    .distinct()
                                    .filter(k -> Character.isAlphabetic(k))
                                    .count();
        return uniqueAlphaCount == 26;
    }

    static boolean pangram3(String sentence){
        // Check if each letter appears at least once
        for (char c = 'a'; c <= 'z'; c++)
            if (!sentence.toLowerCase().contains("" + c))
                return false;
        return true;
    }


    static int findOutlier(int[] integers) {
        // Determine if majority of first elements are even
        int count = (int) Arrays.stream(Arrays.copyOfRange(integers, 0, integers.length))
                          .filter(n -> n % 2 == 0)
                          .count();
        boolean evenDivisor = count >= 2;
        
        // Find the outlier based on determined majority
        return (int) Arrays.stream(integers)
                     .filter(n -> evenDivisor ? n % 2 != 0 : n % 2 == 0)
                     .findFirst()
                     .getAsInt();
    }

    public static int findOutlier2(int[] integers) {
        // Calculate oddness/evenness of first three numbers to determine majority type
        int sum = Arrays.stream(integers)
                    .limit(3)
                    .map(i -> Math.abs(i) % 2)
                    .sum();
                    
        // If sum is 0 or 1, majority is even (looking for odd outlier)
        // If sum is 2 or 3, majority is odd (looking for even outlier)
        int mod = (sum == 0 || sum == 1) ? 1 : 0;

        // Use parallel stream for performance on large arrays
        return Arrays.stream(integers)
                 .parallel()
                 .filter(n -> Math.abs(n) % 2 == mod)
                 .findFirst()
                 .getAsInt();
    }


    public static String highAndLow(String numbers) {
        List<Integer> intList = new ArrayList<>();
        // Parse each number and add to list
        Arrays.stream(numbers.split(" ")).forEach(n -> intList.add(Integer.parseInt(n)));
        Collections.sort(intList);
        // Return highest (last) and lowest (first) after sorting
        return String.valueOf(intList.getLast()) + " " + String.valueOf(intList.getFirst());
    }
    
    public static String highAndLow2(String numbers) {
        // Convert to integers and find min/max directly
        List<Integer> nums = Arrays.stream(numbers.split(" "))
                               .map(Integer::parseInt)
                               .toList();
        return "%s %s".formatted(Collections.max(nums), Collections.min(nums));
    }
}
